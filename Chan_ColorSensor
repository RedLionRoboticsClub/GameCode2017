package org.firstinspires.ftc.teamcode;

import android.graphics.Color;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;

import java.util.Vector;

/**
 * Created by Lea & Kevin on 1/14/2017.
 */
@com.qualcomm.robotcore.eventloop.opmode.Autonomous(name="Chan_SensorColor", group ="Tests")
public class Chan_SensorColor extends LinearOpMode
{

  DcMotor motorLeft;
  DcMotor motorRight;
  DcMotor motorThrow;
  ColorSensor colorSensor;
  private ElapsedTime runtime = new ElapsedTime();
  //We use this to make a new variable called runtime we can use to run the throwing motor off of time.
  private static final int MOTOR_TICKS = 1120;
  // in cm
  private static final double WHEEL_CIRCUMFERENCE = 32.5;
  // this is calculated from center of motor wheels. Is the radius of its turn
  private static final double ROBOT_WIDTH = 34.8;
  private static final double ROBOT_LENGTH = 37.5;

  private Vector<String> log;

  private void addLog (String entry)
  {
    log.add(entry);

    for (int i = 0; i < log.size(); i++)
    {
      telemetry.addData(String.format("%d ",i), log.get(i));
    }
    telemetry.update();
  }

  @Override
  public void runOpMode() throws InterruptedException
  {
    log = new Vector<String>();
    addLog("Thread started");

    // Controller
    motorLeft  = this.hardwareMap.dcMotor.get("motorBL");
    motorRight = this.hardwareMap.dcMotor.get("motorBR");
    motorThrow = this.hardwareMap.dcMotor.get("motorFL");
    colorSensor = this.hardwareMap.colorSensor.get("color sensor");

    motorRight.setDirection(DcMotorSimple.Direction.REVERSE);

    motorLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    motorRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    motorThrow.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

    waitForStart();


    moveMotors(.3, .3, distance(56), distance(56)); // 56cm

    colorRead();

    moveMotors(0,0,0,0);

    addLog("Thread done");
  }

  /**
   * Converts distance in cm to ticks based on rot and motor's encoder ticks.
   * @param cm the distance of travel
   * @return the number of ticks the motor will travel
   */
  int distance (double cm)
  {
    return (int) Math.round((MOTOR_TICKS / WHEEL_CIRCUMFERENCE) * cm);
  }

  /**
   * converts degrees into centimeters relative to the bot
   * @param deg angle in degrees (360)
   * @return distance in centimeters
   */
  double angleToCm (double deg)
  {
    return Math.PI * 2 * ROBOT_WIDTH * (deg / 360);
  }

  void moveMotors (double powerL, double powerR, int posL, int posR) throws InterruptedException
  {
    motorLeft.setMode(DcMotor.RunMode.RESET_ENCODERS);
    motorRight.setMode(DcMotor.RunMode.RESET_ENCODERS);

    waitOneFullHardwareCycle();

    motorLeft.setTargetPosition(posL);
    motorRight.setTargetPosition(posR);

    motorLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    motorRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

    motorLeft.setPower(powerL);
    motorRight.setPower(powerR);

        /*while (((motorLeft.getTargetPosition() - motorLeft.getCurrentPosition() <= 500) &&
                ((motorLeft.getTargetPosition() - motorLeft.getCurrentPosition()) % 100 == 0)) ||
                ((motorRight.getTargetPosition() - motorRight.getCurrentPosition() <= 500) &&
                        ((motorRight.getTargetPosition() - motorRight.getCurrentPosition()) % 100 == 0))
        ){
            powerL = powerL/1.5;
            powerR = powerR/1.5;
            motorLeft.setPower(powerL);
            motorRight.setPower(powerR);
        }*/


    //sleep(5000);

    while (motorLeft.getCurrentPosition() < posL || motorRight.getCurrentPosition() < posR)
    {
      Thread.sleep(20);
    }

  }
  void moveNoEncoders (double powL, double powR, long time) throws InterruptedException
  {
    motorLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    motorRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

    motorLeft.setPower(powL);
    motorRight.setPower(powR);

    sleep(time);
  }

  void motorThrowing (double power, long time) throws InterruptedException
  {
    motorThrow.setPower(power);
    runtime.reset();
    sleep(time);

    motorThrow.setPower(0);
    sleep(100);
  }

 /*   void stopThrowing (double powers, double times) throws InterruptedException
    {
        motorThrow.setPower(powers);
        runtime.reset();
        while (opModeIsActive() && (runtime.seconds() < times))
        {
            idle();
            //Stops Throwing probably a waste of time but is nessarry for now
        }}
   */

  //  void motorThrowing (double power) throws InterruptedException {

//        motorThrow.setPower(power);
  //      Thread.sleep(2);
  //}

  /*
  Assumes robot is parked in front of beacon, within 7cm
   */
  public void colorRead() throws InterruptedException
  {
    colorSensor.enableLed(false);
    sleep(1000);
    float hsvValues[] = {0F, 0F, 0F};
    Color.RGBToHSV(colorSensor.red() * 8, colorSensor.green() * 8, colorSensor.blue() * 8, hsvValues);
    // send the info back to driver station using telemetry function.
    addLog(String.format("Clear", colorSensor.alpha()));
    addLog(String.format("Red  ", colorSensor.red()));
    addLog(String.format("Green", colorSensor.green()));
    addLog(String.format("Blue ", colorSensor.blue()));
    addLog(String.format("Hue", hsvValues[0]));

    if (colorSensor.blue() >= 1)
    {
      //move right wheel forward
      addLog("Blue was spotted");
      moveMotors(0, 0.15, 0, distance(6));
      sleep(2000);
      moveNoEncoders(0, -.15, 1000 );
    }
    else if (colorSensor.red() >= 1)
    {
      //move left wheel forward
      addLog("Red was spotted");
      moveMotors(0, 0.15, 0, distance(6));
      sleep(2000);
      moveNoEncoders(0, -.15, 1000 );
    }
  }
}
